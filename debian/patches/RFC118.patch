--- a/mapogcfilter.c
+++ b/mapogcfilter.c
@@ -565,6 +565,81 @@
 }
 
 /************************************************************************/
+/*                            FLTSplitFilters                           */
+/*                                                                      */
+/*    Split filters separated by parentheses into an array of strings.  */
+/************************************************************************/
+char** FLTSplitFilters(const char* pszStr, int* pnTokens)
+{
+    const char* pszTokenBegin;
+    char** papszRet = NULL;
+    int nTokens = 0;
+    char chStringQuote = '\0';
+    int nXMLIndent = 0;
+    int bInBracket = FALSE;
+
+    if( *pszStr != '(' )
+    {
+        *pnTokens = 0;
+        return NULL;
+    }
+    pszStr ++;
+    pszTokenBegin = pszStr;
+    while( *pszStr != '\0' )
+    {
+        /* Ignore any character until end of quoted string */
+        if( chStringQuote != '\0' )
+        {
+            if( *pszStr == chStringQuote )
+                chStringQuote = 0;
+        }
+        /* Detect begin of quoted string only for an XML attribute, i.e. between < and > */
+        else if( bInBracket && (*pszStr == '\'' || *pszStr == '"') )
+        {
+            chStringQuote = *pszStr;
+        }
+        /* Begin of XML element */
+        else if( *pszStr == '<' )
+        {
+            bInBracket = TRUE;
+            if( pszStr[1] == '/' )
+                nXMLIndent --;
+            else if( pszStr[1] != '!' )
+                nXMLIndent ++;
+        }
+        /* <something /> case */
+        else if (*pszStr == '/' && pszStr[1] == '>' )
+        {
+            bInBracket = FALSE;
+            nXMLIndent --;
+            pszStr ++;
+        }
+        /* End of XML element */
+        else if( *pszStr == '>' )
+        {
+            bInBracket = FALSE;
+        }
+        /* Only detect and of filter when XML indentation goes back to zero */
+        else if( nXMLIndent == 0 && *pszStr == ')' )
+        {
+            papszRet = (char**) msSmallRealloc(papszRet, sizeof(char*) * (nTokens + 1));
+            papszRet[nTokens] = msStrdup(pszTokenBegin);
+            papszRet[nTokens][pszStr - pszTokenBegin] = '\0';
+            nTokens ++;
+            if( pszStr[1] != '(' )
+            {
+                break;
+            }
+            pszStr ++;
+            pszTokenBegin = pszStr + 1;
+        }
+        pszStr ++;
+    }
+    *pnTokens = nTokens;
+    return papszRet;
+}
+
+/************************************************************************/
 /*                            FLTIsSimpleFilter                         */
 /*                                                                      */
 /*      Filter encoding with only attribute queries and only one bbox.  */
--- a/mapogcfilter.h
+++ b/mapogcfilter.h
@@ -60,6 +60,7 @@
 /* -------------------------------------------------------------------- */
 MS_DLL_EXPORT FilterEncodingNode *FLTParseFilterEncoding(const char *szXMLString);
 MS_DLL_EXPORT FilterEncodingNode *FLTCreateFilterEncodingNode(void);
+MS_DLL_EXPORT char** FLTSplitFilters(const char* pszStr, int* pnTokens);
 MS_DLL_EXPORT int FLTApplyFilterToLayer(FilterEncodingNode *psNode, mapObj *map,
                                         int iLayerIndex);
 
--- a/mapwfs.c
+++ b/mapwfs.c
@@ -2217,78 +2217,6 @@
     return MS_SUCCESS;
 }
 
-/*
-** msWFSSplitFilters()
-*/
-static char** msWFSSplitFilters(const char* pszStr, int* pnTokens)
-{
-    const char* pszTokenBegin;
-    char** papszRet = NULL;
-    int nTokens = 0;
-    char chStringQuote = '\0';
-    int nXMLIndent = 0;
-    int bInBracket = FALSE;
-
-    if( *pszStr != '(' )
-    {
-        *pnTokens = 0;
-        return NULL;
-    }
-    pszStr ++;
-    pszTokenBegin = pszStr;
-    while( *pszStr != '\0' )
-    {
-        /* Ignore any character until end of quoted string */
-        if( chStringQuote != '\0' )
-        {
-            if( *pszStr == chStringQuote )
-                chStringQuote = 0;
-        }
-        /* Detect begin of quoted string only for an XML attribute, i.e. between < and > */
-        else if( bInBracket && (*pszStr == '\'' || *pszStr == '"') )
-        {
-            chStringQuote = *pszStr;
-        }
-        /* Begin of XML element */
-        else if( *pszStr == '<' )
-        {
-            bInBracket = TRUE;
-            if( pszStr[1] == '/' )
-                nXMLIndent --;
-            else if( pszStr[1] != '!' )
-                nXMLIndent ++;
-        }
-        /* <something /> case */
-        else if (*pszStr == '/' && pszStr[1] == '>' )
-        {
-            bInBracket = FALSE;
-            nXMLIndent --;
-            pszStr ++;
-        }
-        /* End of XML element */
-        else if( *pszStr == '>' )
-        {
-            bInBracket = FALSE;
-        }
-        /* Only detect and of filter when XML indentation goes back to zero */
-        else if( nXMLIndent == 0 && *pszStr == ')' )
-        {
-            papszRet = (char**) msSmallRealloc(papszRet, sizeof(char*) * (nTokens + 1));
-            papszRet[nTokens] = msStrdup(pszTokenBegin);
-            papszRet[nTokens][pszStr - pszTokenBegin] = '\0';
-            nTokens ++;
-            if( pszStr[1] != '(' )
-            {
-                break;
-            }
-            pszStr ++;
-            pszTokenBegin = pszStr + 1;
-        }
-        pszStr ++;
-    }
-    *pnTokens = nTokens;
-    return papszRet;
-}
 
 /*
 ** msWFSRetrieveFeatures()
@@ -2374,7 +2302,7 @@
     /* -------------------------------------------------------------------- */
     nFilters = 0;
     if (strlen(pszFilter) > 0 && pszFilter[0] == '(') {
-      paszFilter = msWFSSplitFilters(pszFilter, &nFilters);
+      paszFilter = FLTSplitFilters(pszFilter, &nFilters);
 
       if ( paszFilter && nFilters > 0 && numlayers != nFilters ) {
         msFreeCharArray(paszFilter, nFilters);
--- a/mapwms.c
+++ b/mapwms.c
@@ -313,6 +313,160 @@
 }
 
 /*
+** Apply the FILTER parameter to layers (RFC118)
+*/
+int msWMSApplyFilter(mapObj *map, int version, const char *filter,
+		     int def_srs_needs_axis_swap, char *wms_exception_format)
+{
+  int i=0, numlayers;
+  int numfilters=0, curfilter=0;
+  char **paszFilters = NULL;
+  FilterEncodingNode *psNode = NULL;
+
+  if (!map || !filter || strlen(filter)==0)
+    return MS_FAILURE;  
+
+  /* Count number of requested layers 
+   * Only layers with STATUS ON were in the LAYERS request param.
+   * Layers with STATUS DEFAULT were set in the mapfile and are
+   * not expected to have a corresponding filter in the request
+   */
+   for(i=0, numlayers=0; i<map->numlayers; i++) {
+     layerObj *lp=NULL;
+
+     if(map->layerorder[i] != -1) {
+       lp = (GET_LAYER(map,  map->layerorder[i]));
+       if (lp->status == MS_ON)
+	 numlayers++;
+     }
+   }
+   
+  /* -------------------------------------------------------------------- */
+  /*      Parse the Filter parameter. If there are several Filter         */
+  /*      parameters, each Filter is inside parentheses.                  */
+  /* -------------------------------------------------------------------- */
+  numfilters = 0;
+  if (filter[0] == '(') {
+    paszFilters = FLTSplitFilters(filter, &numfilters);
+
+    if ( paszFilters && numfilters > 0 && numlayers != numfilters ) {
+      msFreeCharArray(paszFilters, numfilters);
+      paszFilters = NULL;
+    }
+  } else if (numlayers == 1) {
+    numfilters=1;
+    paszFilters = (char **)msSmallMalloc(sizeof(char *)*numfilters);
+    paszFilters[0] = msStrdup(filter);
+  }
+
+  if (numlayers != numfilters) {
+    msSetError(MS_WFSERR, "Wrong number of filter elements, one filter must be specified for each requested layer.",
+	       "msWMSApplyFilter" );
+    return msWMSException(map, version, "InvalidParameterValue", wms_exception_format);
+  }
+
+  /* We're good to go. Apply each filter to the corresponding layer */
+  for(i=0, curfilter=0; i<map->numlayers && curfilter<numfilters; i++) {
+    layerObj *lp=NULL;
+
+    if(map->layerorder[i] != -1)
+      lp = (GET_LAYER(map,  map->layerorder[i]));
+
+    /* Only layers with STATUS ON were in the LAYERS request param.*/
+    if (lp == NULL || lp->status != MS_ON)
+      continue;
+
+    /* Force setting a template to enable query. */
+    if (lp->template == NULL)
+      lp->template = msStrdup("ttt.html");
+
+    /* Parse filter */
+    psNode = FLTParseFilterEncoding(paszFilters[curfilter]);
+    if (!psNode) {
+      msSetError(MS_WMSERR,
+		 "Invalid or Unsupported FILTER : %s",
+		 "msWMSApplyFilter()", paszFilters[curfilter]);
+      return msWMSException(map, version, "InvalidParameterValue", wms_exception_format);
+    }
+
+    /* For WMS 1.3 and up, we may need to swap the axis of bbox and geometry
+     * elements inside the filter(s)
+     */
+    if (version >= OWS_1_3_0)
+      FLTDoAxisSwappingIfNecessary(psNode, def_srs_needs_axis_swap);
+
+#ifdef do_we_need_this
+    FLTProcessPropertyIsNull(psNode, map, lp->index);
+
+    /*preparse the filter for gml aliases*/
+    FLTPreParseFilterForAliasAndGroup(psNode, map, lp->index, "G");
+
+    /* Check that FeatureId filters are consistent with the active layer */
+    if( FLTCheckFeatureIdFilters(psNode, map, lp->index) == MS_FAILURE)
+      {
+        FLTFreeFilterEncodingNode( psNode );
+        return msWFSException(map, "mapserv", MS_OWS_ERROR_NO_APPLICABLE_CODE, paramsObj->pszVersion);
+      }
+
+    /* FIXME?: could probably apply to WFS 1.1 too */
+    if( nWFSVersion >= OWS_2_0_0 )
+      {
+	int nEvaluation;
+
+        if( FLTCheckInvalidOperand(psNode) == MS_FAILURE)
+        {
+            FLTFreeFilterEncodingNode( psNode );
+            return msWFSException(map, "filter", MS_WFS_ERROR_OPERATION_PROCESSING_FAILED, paramsObj->pszVersion);
+        }
+
+        if( FLTCheckInvalidProperty(psNode, map, lp->index) == MS_FAILURE)
+        {
+            FLTFreeFilterEncodingNode( psNode );
+            return msWFSException(map, "filter", MS_OWS_ERROR_INVALID_PARAMETER_VALUE, paramsObj->pszVersion);
+        }
+
+        psNode = FLTSimplify(psNode, &nEvaluation);
+        if( psNode == NULL )
+        {
+            FLTFreeFilterEncodingNode( psNode );
+            if( nEvaluation == 1 ) {
+                /* return full layer */
+                return msWFSRunBasicGetFeature(map, lp, paramsObj, nWFSVersion);
+            }
+            else {
+                /* return empty result set */
+                return MS_SUCCESS;
+            }
+        }
+
+      }
+    
+#endif
+
+    /* Apply filter to this layer */
+    if( FLTApplyFilterToLayer(psNode, map, lp->index) != MS_SUCCESS ) {
+      errorObj* ms_error = msGetErrorObj();
+
+      if(ms_error->code != MS_NOTFOUND) {
+	msSetError(MS_WFSERR, "FLTApplyFilterToLayer() failed", "msWFSGetFeature()");
+	FLTFreeFilterEncodingNode( psNode );
+	return msWMSException(map, version, "InvalidParameterValue", wms_exception_format);
+      }
+    }
+
+    FLTFreeFilterEncodingNode( psNode );
+
+    curfilter++;
+
+  }/* for */
+
+    // TODO: Set query_map_mode w/ default style...
+
+    
+    return MS_SUCCESS;
+}
+
+/*
 ** msWMSPrepareNestedGroups()
 **
 ** purpose: Parse WMS_LAYER_GROUP settings into arrays
@@ -820,6 +974,9 @@
   const char *sldenabled=NULL;
   char *sld_url=NULL, *sld_body=NULL;
 
+  int need_axis_swap = MS_FALSE;
+  const char *filter = NULL;
+
   epsgbuf[0]='\0';
   srsbuffer[0]='\0';
 
@@ -1135,6 +1292,10 @@
     else if (strcasecmp(names[i], "BBOX_PIXEL_IS_POINT") == 0) {
       bbox_pixel_is_point = (strcasecmp(values[i], "TRUE") == 0);
     }
+    /* Vendor-specific FILTER, added in RFC-118 */
+    else if (strcasecmp(names[i], "FILTER") == 0) {
+      filter = values[i];
+    }
   }
 
   /*validate the exception format WMS 1.3.0 section 7.3.3.11*/
@@ -1160,7 +1321,8 @@
     /*try to adjust the axes if necessary*/
     if (strlen(srsbuffer) > 1) {
       msInitProjection(&proj);
-      if (msLoadProjectionStringEPSG(&proj, (char *)srsbuffer) == 0) {
+      if (msLoadProjectionStringEPSG(&proj, (char *)srsbuffer) == 0 &&
+	  (need_axis_swap = msIsAxisInvertedProj(&proj) ) ) {
         msAxisNormalizePoints( &proj, 1, &rect.minx, &rect.miny );
         msAxisNormalizePoints( &proj, 1, &rect.maxx, &rect.maxy );
       }
@@ -1199,6 +1361,22 @@
   }
 
   /*
+  ** Apply vendor-specific filter if specified
+  */
+  if (filter) {
+    if (sld_url || sld_body) {
+      msSetError(MS_WMSERR,
+                 "Vendor-specific FILTER parameter cannot be used with SLD or SLD_BODY.",
+                 "msWMSLoadGetMapParams()");
+      return msWMSException(map, nVersion, NULL, wms_exception_format);
+    }
+    
+    if (msWMSApplyFilter(map, nVersion, filter, need_axis_swap, wms_exception_format) == MS_FAILURE) {
+      return MS_FAILURE;/* msWMSException(map, nVersion, "InvalidFilterRequest"); */
+    }
+  }
+
+  /*
   ** If any select layers have a default time, we will apply the default
   ** time value even if no TIME request was in the url.
   */
@@ -3610,6 +3788,7 @@
   imageObj *img;
   int i = 0;
   int sldrequested = MS_FALSE,  sldspatialfilter = MS_FALSE;
+  int drawquerymap = MS_FALSE;
   const char *http_max_age;
 
   /* __TODO__ msDrawMap() will try to adjust the extent of the map */
@@ -3638,6 +3817,16 @@
       }
     }
   }
+  /* If FILTER is passed then we'll render layers as querymap */
+  for (i=0; i<numentries; i++) {
+    if ((strcasecmp(names[i], "FILTER") == 0 && values[i] && strlen(values[i]) > 0)) {
+      drawquerymap = MS_TRUE;
+      // TODO: Do we want to allow both selected and hilite?
+      map->querymap.status = MS_ON;
+      map->querymap.style = MS_SELECTED;
+      break;
+    }
+  }
 
   /* turn off layer if WMS GetMap is not enabled */
   for (i=0; i<map->numlayers; i++)
@@ -3679,7 +3868,7 @@
     }
 
   } else
-    img = msDrawMap(map, MS_FALSE);
+    img = msDrawMap(map, drawquerymap);
   if (img == NULL)
     return msWMSException(map, nVersion, NULL, wms_exception_format);
 
--- /dev/null
+++ b/msautotest/wxs/wms_filter.map
@@ -0,0 +1,155 @@
+#
+# Test WMS vendor-specific FILTER (RFC-118)
+#
+# REQUIRES: INPUT=GDAL OUTPUT=PNG SUPPORTS=WMS
+#
+#
+#
+#
+#
+# Regular GetMap 1.3.0
+# RUN_PARMS: wms_filter_getmap130.png [MAPSERV] QUERY_STRING="map=[MAPFILE]&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=EPSG%3A4326&BBOX=40,-70,50,-60&WIDTH=400&HEIGHT=400&LAYERS=province,road,popplace&STYLES=&FORMAT=image%2Fpng&BGCOLOR=0xFFFFFF&TRANSPARENT=FALSE&EXCEPTIONS=INIMAGE" > [RESULT_DEMIME]
+#
+# GetMap 1.3.0 single layer, with property filter
+# RUN_PARMS: wms_filter_getmap130_propertyequalto.png [MAPSERV] QUERY_STRING="map=[MAPFILE]&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=EPSG%3A4326&BBOX=40,-70,50,-60&WIDTH=400&HEIGHT=400&LAYERS=popplace&STYLES=&FORMAT=image%2Fpng&BGCOLOR=0xFFFFFF&TRANSPARENT=FALSE&EXCEPTIONS=INIMAGE&FILTER=<Filter><PropertyIsEqualTo><PropertyName>NAME</PropertyName><Literal>Charlottetown</Literal></PropertyIsEqualTo></Filter>" > [RESULT_DEMIME]
+#
+# GetMap 1.3.0 single layer, with dwithin filter
+# RUN_PARMS: wms_filter_getmap130_dwithin.png [MAPSERV] QUERY_STRING="map=[MAPFILE]&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=EPSG%3A4326&BBOX=40,-70,50,-60&WIDTH=400&HEIGHT=400&LAYERS=road&STYLES=&FORMAT=image%2Fpng&BGCOLOR=0xFFFFFF&TRANSPARENT=FALSE&EXCEPTIONS=INIMAGE&FILTER=<Filter><DWithin><PropertyName>Geometry</PropertyName><gml:Point><gml:coordinates>46,-63</gml:coordinates></gml:Point><Distance units='dd'>0.5</Distance></DWithin></Filter>" > [RESULT_DEMIME]
+#
+# GetMap 1.3.0 two layers, with dwithin filter
+# RUN_PARMS: wms_filter_getmap130_dwithin2.png [MAPSERV] QUERY_STRING="map=[MAPFILE]&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&CRS=EPSG%3A4326&BBOX=40,-70,50,-60&WIDTH=400&HEIGHT=400&LAYERS=road,popplace&STYLES=&FORMAT=image%2Fpng&BGCOLOR=0xFFFFFF&TRANSPARENT=FALSE&EXCEPTIONS=INIMAGE&FILTER=(<Filter><DWithin><PropertyName>Geometry</PropertyName><gml:Point><gml:coordinates>46,-63</gml:coordinates></gml:Point><Distance units='dd'>0.5</Distance></DWithin></Filter>)(<Filter><DWithin><PropertyName>Geometry</PropertyName><gml:Point><gml:coordinates>46,-63</gml:coordinates></gml:Point><Distance units='dd'>0.5</Distance></DWithin></Filter>)" > [RESULT_DEMIME]
+#
+
+
+MAP
+
+NAME WMS_SLD
+STATUS ON
+SIZE 400 300
+#EXTENT   2018000 -73300 3410396 647400
+#UNITS METERS
+EXTENT -67.5725 42 -58.9275 48.5
+UNITS DD
+IMAGECOLOR 255 255 255
+SHAPEPATH ./data
+SYMBOLSET etc/symbols.sym
+FONTSET etc/fonts.txt
+#
+# Start of web interface definition
+#
+WEB
+
+ IMAGEPATH "/tmp/ms_tmp/"
+ IMAGEURL "/ms_tmp/"
+
+  METADATA
+    "wms_title"		   "Test simple wms"
+    "wms_onlineresource"   "http://localhost/path/to/wms_simple?"
+    "wms_srs"		   "EPSG:3978 EPSG:42101 EPSG:4269 EPSG:4326"
+    "ows_schemas_location" "http://ogc.dmsolutions.ca"
+    "ows_enable_request" "*" 
+  END
+
+  VALIDATION
+     "sld_external_graphic" "^.*/misc/data.*"
+  END
+END
+
+PROJECTION
+   "init=epsg:4326"
+END
+
+
+#
+# Start of layer definitions
+#
+
+
+
+LAYER
+  NAME province
+  DATA province
+  METADATA
+    "wms_title"         "province"
+    "wms_description"   "province"
+    "wms_result_fields" "NAME_E YEAR_EST AREA_KMSQ"
+  END
+  TYPE POINT
+  STATUS ON
+  PROJECTION
+    "init=epsg:3978"
+  END
+
+  DUMP TRUE
+  CLASSITEM "Name_e"
+
+  CLASS
+    NAME "Province"
+    COLOR 200 255 0
+    OUTLINECOLOR 120 120 120
+  END
+END # Layer
+
+
+LAYER
+  NAME popplace
+  DATA popplace
+  METADATA
+    "wms_title"         "popplace"
+    "wms_description"   "Cities of I.P.E."
+    "wms_result_fields" "NAME"
+    "gml_NAME_alias" "NAME_ALIAS"
+  END
+  TYPE POINT
+  STATUS ON
+  PROJECTION
+    "init=epsg:3978"
+  END
+
+  DUMP TRUE
+  LabelItem "Name"
+  CLASSITEM "Capital" 
+
+  CLASS
+    EXPRESSION /./  
+    SYMBOL 2
+    SIZE 8
+    NAME "Cities"
+    LABEL
+      COLOR  0 0 0
+      FONT Vera
+      TYPE truetype
+      SIZE 8
+      POSITION AUTO			
+      PARTIALS FALSE
+      OUTLINECOLOR 255 255 255			
+    END 
+    COLOR 0 0 0
+  END
+END # Layer
+
+LAYER
+  NAME road
+  DATA road
+  METADATA
+    "wms_title"       "road"
+    "wms_description" "Roads of I.P.E."
+  END
+  TYPE LINE
+  STATUS ON
+  PROJECTION
+    "init=epsg:3978"
+  END
+
+  DUMP TRUE
+
+  CLASSITEM "Name_e"
+  CLASS
+    NAME "Roads"
+    SYMBOL 0 
+    COLOR 220 0 0
+  END
+END # Layer
+
+
+END # Map File
